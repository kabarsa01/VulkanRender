#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable


#include "CommonFrameData.glsl"
#include "CommonRay.glsl"
#include "CommonSampling.glsl"
#include "CommonLight.glsl"
#include "CommonDepth.glsl"

layout(location = 0) rayPayloadEXT HitPayloadDebug payloadDebug;
layout(location = 1) rayPayloadEXT HitPayloadGI payloadGI;

//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
// SET 1

layout(set = 1, binding = 0) uniform texture2D normalTex;
layout(set = 1, binding = 1) uniform texture2D depthTex;
// light clustering data
layout(set = 1, binding = 2) readonly buffer ClusterLightsData
{
	uvec2 clusters[32][32][64];
	uint lightIndices[32][32][64][128];
} clusterLightsData;
// lights list data
struct LightInfo
{
	vec4 position;
	vec4 direction;
	vec4 color;
	vec4 rai;
};
layout(set = 1, binding = 3) uniform LightsList
{
	LightInfo lights[1024];
} lightsList;
layout(set = 1, binding = 4) uniform LightsIndices
{
	uvec2 directionalPosition;
	uvec2 spotPosition;
	uvec2 pointPosition;
} lightsIndices;

layout(set = 1, binding = 5) uniform accelerationStructureEXT tlas;
layout(set = 1, binding = 6, rgba16f) uniform image2D lightTex;
layout(set = 1, binding = 7, rgba8) uniform image2D visibilityTextures[32];

//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
// SET 2

layout(set = 2, binding = 0) uniform SamplingPoints
{
//	CoordinateList samplingPoints;
	vec4 coords[2048];
	uint size;
} samplingPoints;

layout(buffer_reference, std430, buffer_reference_align = 4) buffer Grid
{
	uvec2 lightOffsets[25][25][25];
    uint data[25][25][25][128];
};

layout(buffer_reference, std430, buffer_reference_align = 8) buffer Grids
{
	Grid grid[];
};

layout(set = 2, binding = 1) readonly buffer GridLightsData
{
	uvec4 gridSpecs;
	uint lightsPerCell;
	Grids gridList;
} gridLightsData;

layout(set = 2, binding = 2) uniform texture2D directLightTex;
layout(set = 2, binding = 3, rgba16f) uniform readonly image2D previousLightTex;
layout(set = 2, binding = 4) uniform texture2D previousDepthTex;
layout(set = 2, binding = 5) uniform texture2D previousNormalTex;
layout(set = 2, binding = 6) uniform texture2D velocityTex;
layout(set = 2, binding = 7) uniform texture2D albedoTex;

layout(set = 2, binding = 8, r32ui) uniform uimage2D counterTex;
layout(set = 2, binding = 9, r32f) uniform image2D giDepthTex;

layout(set = 3, binding = 0, rgba16f) uniform image2D irradianceTex;
//layout(set = 2, binding = 11, rgba16f) uniform image2D irradianceTex;

//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------

bool IsScreenSpaceProbeFit(in vec3 pixelWorldPos, in vec3 probeWorldPos, in vec3 pixelWorldNormal, in vec3 probeWorldNormal)
{
	// TODO

	return true;
}

//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------

vec3 SampleIllumination(vec3 worldPos, vec2 uvCoord)
{
	ivec2 imgSize = imageSize(previousLightTex);
	vec2 pixelCoord = vec2(imgSize) * uvCoord;
	ivec2 pixelCoordMin = ivec2(floor(pixelCoord - vec2(0.5, 0.5)));

	vec2 alpha = pixelCoord - (vec2(pixelCoordMin) + vec2(0.5, 0.5));

	for (int idx = 0; idx < 4; idx++)
	{
		ivec2 pixelIndex = ivec2(idx / 2, idx & 1);
		pixelIndex += pixelCoordMin;

		// TODO test probe against current pixel
		// TODO get probe world coord
		vec2 probeUV = (vec2(pixelIndex) + vec2(0.5, 0.5)) / vec2(imgSize);
		float depth = texture(sampler2D( previousDepthTex, borderBlackNearestSampler ), probeUV).r;
		float linearDepth = LinearizeDepth(depth, globalPreviousData.cameraNear, globalPreviousData.cameraFar);

		// TODO load illumination for bilinear sampling
		vec3 probeIllumination = imageLoad(previousLightTex, pixelIndex).xyz;
	}

	// TODO return actual illumination
	return vec3(0.0);
}

//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------

bool CheckAndAccumulateViewSpaceVisibility(vec3 rayOrigin, vec4 worldSpacePos, vec4 viewSpacePosition, inout vec3 color)
{
	// view z reject check
	if (viewSpacePosition.z < globalData.cameraNear || viewSpacePosition.z > globalData.cameraFar)
	{
		return false;
	}
	float maxY = viewSpacePosition.z * tan(radians(globalData.cameraFov * 0.5));
	float maxX = maxY * globalData.cameraAspect;
	// view width/height reject check
	if (abs(viewSpacePosition.x) > abs(maxX) || abs(viewSpacePosition.y) > abs(maxY))
	{
		return false;
	}

	vec2 halfScreenOffset = vec2(maxX, maxY);
	vec2 uv = (viewSpacePosition.xy + halfScreenOffset) / (halfScreenOffset * 2.0f);

	// compare depth in this point
	float depth = texture(sampler2D( depthTex, borderBlackNearestSampler ), uv).r;
	if (depth == 0.0 || depth >= 1.0)
	{
		return false;
	}

	float near = globalData.cameraNear;
	float far = globalData.cameraFar;
	float linearDepth = LinearizeDepth(depth, near, far);

	vec4 pixelCoordWorld = CalculateWorldPosition(linearDepth, globalData.cameraFov, globalData.cameraAspect, uv, globalData.worldToView);

	if (length(pixelCoordWorld.xyz - worldSpacePos.xyz) > 0.75)
	{
		return false;
	}

//	vec2 uvPrev = uv + texture(sampler2D( velocityTex, repeatLinearSampler ), uv).xy / 10.0;
//	float prevDepth = texture(sampler2D( previousDepthTex, repeatLinearSampler ), uv).r;
//	float prevLinearDepth = LinearizeDepth(prevDepth, near, far);

	//if (abs(linearDepth - prevLinearDepth) >= 0.01f)
	{
//		return false;
	}

	// TODO sample direct light at this point
	color = texture(sampler2D(directLightTex, repeatLinearSampler), uv).xyz;

	vec2 probeIndex = uv * vec2(gl_LaunchSizeEXT.xy);
	vec3 N = normalize( texture( sampler2D( normalTex, borderBlackNearestSampler ), uv ).xyz );
	//for (uint idx = 0; idx < 4; idx++)
	{
		vec3 rayVector = worldSpacePos.xyz - rayOrigin;
		vec2 probeUV = DirectionToOctahedronUV(normalize( reflect(rayVector, N) ));
		ivec2 pixelCoord = ivec2(probeIndex) * ivec2(8,8) + ivec2(1,1) + ivec2(probeUV * 6.0);
		vec3 light = imageLoad(lightTex, pixelCoord).xyz;
//		for (int x = 0; x < 8; x++) 
//		{
//			ivec2 offset = ivec2(x / 3 - 1, x % 3 - 1);
//			light += imageLoad(lightTex, pixelCoord + offset).xyz;
//		}
//		light /= 9.0f;
		float distanceFactor = clamp(1.0 - length(rayVector) / 100.0, 0.0, 1.0);
		distanceFactor *= distanceFactor;
		color += imageLoad(irradianceTex, ivec2(gl_LaunchIDEXT.xy)).xyz;//light;
		color *= distanceFactor;
	}

	return true;
}

//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------

void main() 
{
	float tMin = 0.1f;
	float tMax = 100.f;
    uint rayFlags = gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT;
	uint temporalCounter = 0;
	//vec3 accumulatedLight = vec3(0.0f, 0.0f, 0.0f);
	ivec2 lightTexSize = imageSize(lightTex);
	ivec2 tempCounterTexSize = imageSize(counterTex);

	//----------------------------------------------------------------------------------------------------------------------------------
	// extract UVs 
	const vec2 screenProbeCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5, 0.5);
    const vec2 uv = screenProbeCenter/vec2(gl_LaunchSizeEXT.xy);
	const vec2 velocity = texture( sampler2D( velocityTex, borderBlackNearestSampler ), uv ).xy / 10.0f;
	const vec2 prevUV = uv + velocity;

	//----------------------------------------------------------------------------------------------------------------------------------
	// albedo
	vec3 albedo = texture(sampler2D( albedoTex, repeatLinearSampler ), uv).xyz;

	//----------------------------------------------------------------------------------------------------------------------------------
	// extract depth and world positions
	float near = globalData.cameraNear;
	float far = globalData.cameraFar;
	float depth = texture(sampler2D( depthTex, borderBlackNearestSampler ), uv).r;
	imageStore(giDepthTex, ivec2(gl_LaunchIDEXT.xy), vec4(depth, 0.0f, 0.0f, 0.0));
	if (depth <= 0.0f || depth >= 1.0f)
	{
//		imageStore(lightTex, ivec2(gl_LaunchIDEXT.xy), vec4(0.0f, 0.0f, 0.0f, 1.0));
//		return;
	}
	float linearDepth = near * far / (far + depth * (near - far));
	vec4 pixelCoordWorld = CalculateWorldPosition(linearDepth, globalData.cameraFov, globalData.cameraAspect, uv, globalData.worldToView);

	float previousDepth = texture(sampler2D( previousDepthTex, borderBlackNearestSampler ), prevUV).r;
	float previousLinearDepth = LinearizeDepth(previousDepth, globalPreviousData.cameraNear, globalPreviousData.cameraFar);
	vec4 previousPixelCoordWorld = CalculateWorldPosition(previousLinearDepth, globalPreviousData.cameraFov, globalPreviousData.cameraAspect, prevUV, globalPreviousData.worldToView);

	//----------------------------------------------------------------------------------------------------------------------------------
	// extract normal
	vec3 N = normalize( texture( sampler2D( normalTex, borderBlackNearestSampler ), uv ).xyz );
	//----------------------------------------------------------------------------------------------------------------------------------
	// load temporal counter
	temporalCounter = imageLoad(counterTex, ivec2(tempCounterTexSize * prevUV)).r;

	//----------------------------------------------------------------------------------------------------------------------------------
	// extract normals data
	//vec3 N = normalize( texture( sampler2D( normalTex, borderBlackLinearSampler ), uv ).xyz );
	vec3 tangent, bitangent;
	CreateCoordinateSystem(N, tangent, bitangent);
	tangent = normalize(tangent);
	bitangent = normalize(bitangent);
	// ray start
	vec3 rayStart = pixelCoordWorld.xyz;// + (N * 0.05f);

	uint samplePoolSize = /*temporalCounter == 0 ? 16 :*/ 31101;
	uint sampleStep = samplePoolSize / 256;
	uint sampleStart = temporalCounter % sampleStep;
	uint randSeed = InitRNG(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, globalData.frameIndex);

	vec3 integratedLight = vec3(0.0f);

	for (uint idx = sampleStart; idx < samplePoolSize; idx += sampleStep)
	{
		vec3 accumulatedLight = vec3(0.0f);

		vec3 jitter = vec3(Rand(randSeed), Rand(randSeed), Rand(randSeed));
		jitter = 0.05f * normalize(jitter - vec3(0.5f));

		vec3 hemisphereDir = normalize(SphericalFibonacci(idx, samplePoolSize)) + jitter;
		hemisphereDir.z = abs(hemisphereDir.z);
		vec3 direction = normalize( hemisphereDir.x * tangent + hemisphereDir.y * bitangent + hemisphereDir.z * N );

		float initialSurfaceCos = clamp( dot(N, direction), 0.0f, 1.0f );

		traceRayEXT(tlas,							// acceleration structure
				rayFlags,							// rayFlags
				0xFF,								// cullMask
				1,									// sbtRecordOffset
				0,									// sbtRecordStride
				0,									// missIndex
				rayStart,							// ray origin
				tMin,								// ray min range
				direction,							// ray direction
				tMax,								// ray max range
				1									// payload (location = 0)
		);

		if (payloadGI.instanceCustomId == 0xffffffff)
		{
			continue;
		}
		uint initialInstanceId = payloadGI.instanceCustomId;
		float hitDistance = payloadGI.hitT;
		vec3 hitPosBiased = rayStart + direction * clamp(hitDistance - 0.5f, hitDistance * 0.2f, hitDistance);

		//------------------------------------------------------------------------------------------------------------------------------------------------
		//------------------------------------------------------------------------------------------------------------------------------------------------
		// falloff
		vec3 pointDistance = rayStart - payloadGI.worldPos;
		float lightMaxRadius = 100.0;
		float initialDistanceFactor = clamp(1.0 - length(pointDistance) / lightMaxRadius, 0.0, 1.0);
		initialDistanceFactor *= initialDistanceFactor;
		//------------------------------------------------------------------------------------------------------------------------------------------------
		//------------------------------------------------------------------------------------------------------------------------------------------------

		vec4 hitPointViewSpace = globalData.worldToView * vec4(payloadGI.worldPos, 1.0f);
		hitPointViewSpace /= hitPointViewSpace.w;
		hitPointViewSpace.z *= -1.0f; // my coordinate systems and LH-RH shennanigans, sorry

//		vec3 directColor = vec3(0.0f);
//		if (CheckAndAccumulateViewSpaceVisibility(rayStart, vec4(payloadGI.worldPos, 1.0f), hitPointViewSpace, directColor))
//		{
//			accumulatedLight += directColor;
//			//accumulatedLight *= initialDistanceFactor;// * initialSurfaceCos / 2.0f;
//			integratedLight += accumulatedLight * initialSurfaceCos;
//			{
//				vec2 probeUV = DirectionToOctahedronUV(direction);
//				ivec2 pixelCoord = ivec2(gl_LaunchIDEXT.xy) * ivec2(8,8) + ivec2(1,1) + clamp(ivec2(probeUV * 6.0), 0, 5);
//				//vec4 light = imageLoad(lightTex, pixelCoord);
//				vec4 light = imageLoad(lightTex, pixelCoord);
//				light = mix(light, vec4(accumulatedLight, hitDistance), 3.0f / float(sampleStep));
//				imageStore(lightTex, pixelCoord, light);
//
//				ivec2 reflectedPixel = ivec2(probeUV * vec2(6.0, 6.0));
//				if (OctahedronReflectBorderPixelIndex(ivec2(6), ivec2(probeUV * vec2(6.0, 6.0)), reflectedPixel))
//				{
//					ivec2 currentPixel = reflectedPixel + ivec2(gl_LaunchIDEXT.xy) * ivec2(8,8) + ivec2(1,1);
//					imageStore(lightTex, currentPixel, light);
//				}
//			}
//			continue;
//		}

		vec3 gridVector = payloadGI.worldPos - globalData.cameraPos;
		float maxExtent = 2.0f * max(abs(gridVector.x), max(abs(gridVector.y), abs(gridVector.z)));
		float gridExtent = gridLightsData.gridSpecs.x;
		uint gridIndex = 0;
		for (; gridIndex < gridLightsData.gridSpecs.w; gridIndex++)
		{
			if (maxExtent <= gridExtent)
			{
				break;
			}
			gridExtent *= 5.0f;
		}
		vec3 gridCellSize = vec3(gridExtent * 0.04f);
		uvec3 gridCellIndex = uvec3((vec3(gridExtent * 0.5f) + gridVector) / gridCellSize);

		uint lightsCount = gridLightsData.gridList.grid[gridIndex].data[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z][0];
		for (uint lightIndex = 2; lightIndex < lightsCount + 2; lightIndex++)
		{
			uint lightIndicesPacked = gridLightsData.gridList.grid[gridIndex].data[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z][lightIndex / 2];
			LightInfo lightInfo = lightsList.lights[UnpackLightIndex(lightIndicesPacked, lightIndex)];
		}

		//------------------------------------------------------------------------------------------------------------------------------------------------

		uvec2 lightsPositions = gridLightsData.gridList.grid[gridIndex].lightOffsets[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z];
		uint directionalCount = (lightsPositions.x >> 8) & 0x000000ff;
		uint directionalOffset = lightsPositions.x & 0x000000ff;
		uint spotCount = (lightsPositions.x >> 24) & 0x000000ff;
		uint spotOffset = (lightsPositions.x >> 16) & 0x000000ff;
		uint pointCount = (lightsPositions.y >> 8) & 0x000000ff;
		uint pointOffset = lightsPositions.y & 0x000000ff;

		uint lightIndex = 0;
		for (uint index = directionalOffset; index < directionalOffset + directionalCount; index++)
		{
			uint lightIndicesPacked = gridLightsData.gridList.grid[gridIndex].data[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z][index / 2];
			LightInfo lightInfo = lightsList.lights[UnpackLightIndex(lightIndicesPacked, index)];

			vec3 pixelToLightDir = -lightInfo.direction.xyz;
			//float surfaceCosine = dot(normalize(pixelToLightDir), N);

//			if (surfaceCosine >= 0.0f)
			{
				traceRayEXT(tlas,						// acceleration structure
					  rayFlags,							// rayFlags
					  0xFF,								// cullMask
					  1,								// sbtRecordOffset
					  0,								// sbtRecordStride
					  0,								// missIndex
					  //payloadGI.worldPos,				// ray origin
					  hitPosBiased,
					  tMin,								// ray min range
					  normalize(pixelToLightDir.xyz),	// ray direction
					  tMax,								// ray max range
					  1									// payload (location = 0)
				);
				if (payloadGI.instanceCustomId == 0xffffffff)
				{
					accumulatedLight += lightInfo.color.xyz;
				}
			}
		}
		for (uint index = spotOffset; index < spotOffset + spotCount; index++)
		{
			uint lightIndicesPacked = gridLightsData.gridList.grid[gridIndex].data[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z][index / 2];
			LightInfo lightInfo = lightsList.lights[UnpackLightIndex(lightIndicesPacked, index)];

			vec3 pixelToLightDir = lightInfo.position.xyz - payloadGI.worldPos;
			float cosine = dot( normalize(-1.0 * pixelToLightDir), normalize(lightInfo.direction.xyz) );
			float spotCosine = cos(radians(lightInfo.rai.y));
			float angleFactor = clamp(cosine - spotCosine, 0.0f, 1.0f);// / clamp(1.0f - spotCosine, 0.0f, 1.0f);
			//float surfaceCosine = dot(normalize(pixelToLightDir), N);

			//if (surfaceCosine >= 0.0f)
			{
				traceRayEXT(tlas,							// acceleration structure
					  rayFlags,								// rayFlags
					  0xFF,									// cullMask
					  1,									// sbtRecordOffset
					  0,									// sbtRecordStride
					  0,									// missIndex
					  //payloadGI.worldPos,					// ray origin
					  hitPosBiased,
					  tMin,									// ray min range
					  normalize(pixelToLightDir.xyz),		// ray direction
					  length(pixelToLightDir),				// ray max range
					  1										// payload (location = 0)
				);
				if (payloadGI.instanceCustomId == 0xffffffff)
				{
					float distanceFactor = clamp(1.0 - length(pixelToLightDir) / lightInfo.rai.x, 0.0, 1.0);
					distanceFactor *= distanceFactor;
					accumulatedLight += angleFactor * distanceFactor * lightInfo.color.xyz;
				}
			}
		}
		for (uint index = pointOffset; index < pointOffset + pointCount; index++)
		{
			uint lightIndicesPacked = gridLightsData.gridList.grid[gridIndex].data[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z][index / 2];
			LightInfo lightInfo = lightsList.lights[UnpackLightIndex(lightIndicesPacked, index)];

			vec3 pixelToLightDir = lightInfo.position.xyz - payloadGI.worldPos;
			//float surfaceCosine = dot(normalize(pixelToLightDir), N);

			//if (surfaceCosine >= 0.0f)
			{
				traceRayEXT(tlas,								// acceleration structure
					  rayFlags,									// rayFlags
					  0xFF,										// cullMask
					  1,										// sbtRecordOffset
					  0,										// sbtRecordStride
					  0,										// missIndex
					  //payloadGI.worldPos,						// ray origin
					  hitPosBiased,
					  tMin,										// ray min range
					  normalize(pixelToLightDir.xyz),			// ray direction
					  length(pixelToLightDir),					// ray max range
					  1											// payload (location = 0)
				);
				if (payloadGI.instanceCustomId == 0xffffffff)
				{
					float distanceFactor = clamp(1.0 - length(pixelToLightDir) / lightInfo.rai.x, 0.0, 1.0);
					distanceFactor *= distanceFactor;
					accumulatedLight += distanceFactor * lightInfo.color.xyz;
				}
			}
		}
		
		accumulatedLight *= initialDistanceFactor;
		integratedLight += accumulatedLight * initialSurfaceCos;

		vec2 probeUV = DirectionToOctahedronUV(direction);
		ivec2 pixelCoord = ivec2(gl_LaunchIDEXT.xy) * ivec2(8,8) + ivec2(1,1) + clamp(ivec2(probeUV * 6.0), 0, 5);

		vec4 light = imageLoad(lightTex, pixelCoord);
		light = mix(light, vec4(accumulatedLight, hitDistance), 3.0f / float(sampleStep));
		imageStore(lightTex, pixelCoord, light);

		ivec2 reflectedPixel = ivec2(probeUV * vec2(6.0, 6.0));
		if (OctahedronReflectBorderPixelIndex(ivec2(6), ivec2(probeUV * vec2(6.0, 6.0)), reflectedPixel))
		{
			ivec2 currentPixel = reflectedPixel + ivec2(gl_LaunchIDEXT.xy) * ivec2(8,8) + ivec2(1,1);
			imageStore(lightTex, currentPixel, light);
		}
	}

	vec4 totalLight = imageLoad(irradianceTex, ivec2(gl_LaunchIDEXT.xy));
	totalLight = mix(totalLight, vec4(integratedLight, 1.0), 3.0f / float(sampleStep));
	imageStore(irradianceTex, ivec2(gl_LaunchIDEXT.xy), totalLight);

	++temporalCounter;
	imageStore(counterTex, ivec2(gl_LaunchIDEXT.xy), uvec4(temporalCounter, 0,0,0));
}