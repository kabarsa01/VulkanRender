#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable


#include "CommonFrameData.glsl"
#include "CommonRay.glsl"
#include "CommonSampling.glsl"
#include "CommonLight.glsl"
#include "CommonDepth.glsl"

layout(location = 0) rayPayloadEXT HitPayloadDebug payloadDebug;
layout(location = 1) rayPayloadEXT HitPayloadGI payloadGI;

//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
// SET 1

layout(set = 1, binding = 0) uniform texture2D normalTex;
layout(set = 1, binding = 1) uniform texture2D depthTex;
// light clustering data
layout(set = 1, binding = 2) readonly buffer ClusterLightsData
{
	uvec2 clusters[32][32][64];
	uint lightIndices[32][32][64][128];
} clusterLightsData;
// lights list data
struct LightInfo
{
	vec4 position;
	vec4 direction;
	vec4 color;
	vec4 rai;
};
layout(set = 1, binding = 3) uniform LightsList
{
	LightInfo lights[1024];
} lightsList;
layout(set = 1, binding = 4) uniform LightsIndices
{
	uvec2 directionalPosition;
	uvec2 spotPosition;
	uvec2 pointPosition;
} lightsIndices;

layout(set = 1, binding = 5) uniform accelerationStructureEXT tlas;
layout(set = 1, binding = 6, rgba16f) uniform image2D lightTex;
layout(set = 1, binding = 7, rgba8) uniform image2D visibilityTextures[32];

//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
// SET 2

layout(set = 2, binding = 0) uniform SamplingPoints
{
//	CoordinateList samplingPoints;
	vec4 coords[2048];
	uint size;
} samplingPoints;

layout(buffer_reference, std430, buffer_reference_align = 4) buffer Grid
{
	uvec2 lightOffsets[25][25][25];
    uint data[25][25][25][128];
};

layout(buffer_reference, std430, buffer_reference_align = 8) buffer Grids
{
	Grid grid[];
};

layout(set = 2, binding = 1) readonly buffer GridLightsData
{
	uvec4 gridSpecs;
	uint lightsPerCell;
	Grids gridList;
} gridLightsData;

layout(set = 2, binding = 2) uniform texture2D directLightTex;
layout(set = 2, binding = 3) uniform texture2D previousLightTex;
layout(set = 2, binding = 4) uniform texture2D previousDepthTex;
layout(set = 2, binding = 5) uniform texture2D velocityTex;
layout(set = 2, binding = 6) uniform texture2D albedoTex;
layout(set = 2, binding = 7, r32ui) uniform uimage2D counterTex;

//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------

bool CheckAndAccumulateViewSpaceVisibility(vec4 viewSpacePosition, inout vec3 color)
{
	if (viewSpacePosition.z < globalData.cameraNear || viewSpacePosition.z > globalData.cameraFar)
	{
		return false;
	}
	float maxY = viewSpacePosition.z * tan(radians(globalData.cameraFov * 0.5));
	float maxX = maxY * globalData.cameraAspect;

	if (abs(viewSpacePosition.x) > abs(maxX) || abs(viewSpacePosition.y) > abs(maxY))
	{
		return false;
	}

	vec2 halfScreenOffset = vec2(maxX, maxY);
	vec2 uv = (viewSpacePosition.xy + halfScreenOffset) / (halfScreenOffset * 2.0f);

	// compare depth in this point
	float depth = texture(sampler2D( depthTex, repeatLinearSampler ), uv).r;
	if (depth == 0.0 || depth >= 1.0)
	{
		return false;
	}

	float near = globalData.cameraNear;
	float far = globalData.cameraFar;
	float linearDepth = near * far / (far + depth * (near - far));

	if (abs(linearDepth - viewSpacePosition.z) >= 0.01f)
	{
		return false;
	}

	vec2 uvPrev = uv + texture(sampler2D( velocityTex, repeatLinearSampler ), uv).xy;
	float prevDepth = texture(sampler2D( previousDepthTex, repeatLinearSampler ), uv).r;
	float prevLinearDepth = LinearizeDepth(prevDepth, near, far);

	if (abs(linearDepth - prevLinearDepth) >= 0.01f)
	{
		return false;
	}

	color = texture(sampler2D(previousLightTex, repeatLinearSampler), uvPrev).xyz;

	return true;
}

//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------

void main() 
{
	float tMin = 0.1f;
	float tMax = 1000.f;
    uint rayFlags = gl_RayFlagsOpaqueEXT;
	uint temporalCounter = 0;
	vec3 totalLight = vec3(0.0f, 0.0f, 0.0f);
	vec3 accumulatedLight = vec3(0.0f, 0.0f, 0.0f);

	//----------------------------------------------------------------------------------------------------------------------------------
	// extract UVs 
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5, 0.5);
    const vec2 uv = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	const vec2 prevUV = uv + texture( sampler2D( velocityTex, repeatLinearSampler ), uv ).xy;

	//----------------------------------------------------------------------------------------------------------------------------------
	// albedo
	vec3 albedo = texture(sampler2D( albedoTex, repeatLinearSampler ), uv).xyz;

	//----------------------------------------------------------------------------------------------------------------------------------
	// extract depth 
	float near = globalData.cameraNear;
	float far = globalData.cameraFar;
	float depth = texture(sampler2D( depthTex, repeatLinearSampler ), uv).r;
	if (depth == 0.0 || depth >= 1.0)
	{
		imageStore(lightTex, ivec2(gl_LaunchIDEXT.xy), vec4(0.0f, 0.0f, 0.0f, 1.0));
		return;
	}
	float linearDepth = near * far / (far + depth * (near - far));

	float height = 2.0 * linearDepth * tan(radians(globalData.cameraFov * 0.5));
	float width = height * globalData.cameraAspect;
	float pixelViewSpaceX = width * (-0.5 + uv.x);
	float pixelViewSpaceY = height * (-0.5 + uv.y);
	vec4 pixelCoordWorld = inverse(globalData.worldToView) * vec4(pixelViewSpaceX, pixelViewSpaceY, -linearDepth, 1.0);
	pixelCoordWorld /= pixelCoordWorld.w;

	float previousDepth = texture(sampler2D( previousDepthTex, repeatLinearSampler ), prevUV).r;
	float previousLinearDepth = LinearizeDepth(previousDepth, near, far);
	if (abs(previousLinearDepth - linearDepth) <= 0.2f)
	{
		temporalCounter = imageLoad(counterTex, ivec2(gl_LaunchIDEXT.xy)).r;
		totalLight = texture( sampler2D( previousLightTex, repeatLinearSampler ), prevUV ).xyz;
	}

	//----------------------------------------------------------------------------------------------------------------------------------
	// extract normals data
	vec3 N = normalize( texture( sampler2D( normalTex, repeatLinearSampler ), uv ).xyz );
	vec3 tangent, bitangent;
	CreateCoordinateSystem(N, tangent, bitangent);
	tangent = normalize(tangent);
	bitangent = normalize(bitangent);
	// ray start
	vec3 rayStart = pixelCoordWorld.xyz + (N * 0.05f);

	uint samplePoolSize = 8192;
	uint sampleStep = samplePoolSize / 32;
	uint sampleStart = temporalCounter % sampleStep;
	uint jitterSeed = tea(temporalCounter, sampleStart);
	for (uint idx = sampleStart; idx < samplePoolSize; idx += sampleStep)
	{
		vec3 jitter = vec3(rnd(jitterSeed), rnd(jitterSeed), rnd(jitterSeed));
		jitter = (normalize(jitter) - vec3(0.5f)) * 0.1;

		vec3 hemisphereDir = SphericalFibonacci(idx, samplePoolSize) + jitter;
		hemisphereDir.z = abs(hemisphereDir.z);
		vec3 direction = normalize( hemisphereDir.x * tangent + hemisphereDir.y * bitangent + hemisphereDir.z * N );

		float initialSurfaceCos = clamp( dot(N, direction), 0.0f, 1.0f );

		traceRayEXT(tlas,							// acceleration structure
				rayFlags,							// rayFlags
				0xFF,								// cullMask
				1,									// sbtRecordOffset
				0,									// sbtRecordStride
				0,									// missIndex
				rayStart,							// ray origin
				tMin,								// ray min range
				direction,							// ray direction
				tMax,								// ray max range
				1									// payload (location = 0)
		);

		if (payloadGI.instanceCustomId == 0xffffffff)
		{
			continue;
		}
		uint initialInstanceId = payloadGI.instanceCustomId;

		//------------------------------------------------------------------------------------------------------------------------------------------------
		//------------------------------------------------------------------------------------------------------------------------------------------------
		// falloff
		vec3 pointDistance = rayStart - payloadGI.worldPos;
		float lightMaxRadiusSqr = 1000000.0;
		float pointDistanceSqr = dot(pointDistance, pointDistance);
		float initialDistanceFactor = max(lightMaxRadiusSqr - pointDistanceSqr, 0) / max(lightMaxRadiusSqr, 0.001);
		//------------------------------------------------------------------------------------------------------------------------------------------------
		//------------------------------------------------------------------------------------------------------------------------------------------------

		vec4 hitPointViewSpace = globalData.worldToView * vec4(payloadGI.worldPos, 1.0f);
		hitPointViewSpace /= hitPointViewSpace.w;
		hitPointViewSpace.z *= -1.0f; // my coordinate systems and LH-RH shennanigans, sorry

		vec3 directColor = vec3(0.0f);
		if (CheckAndAccumulateViewSpaceVisibility(hitPointViewSpace, directColor))
		{
			accumulatedLight += directColor;
			accumulatedLight *= initialDistanceFactor * initialSurfaceCos / 2.0f;
		}

		vec3 gridVector = payloadGI.worldPos - globalData.cameraPos;
		float maxExtent = 2.0f * max(abs(gridVector.x), max(abs(gridVector.y), abs(gridVector.z)));
		float gridExtent = gridLightsData.gridSpecs.x;
		uint gridIndex = 0;
		for (; gridIndex < gridLightsData.gridSpecs.w; gridIndex++)
		{
			if (maxExtent <= gridExtent)
			{
				break;
			}
			gridExtent *= 5.0f;
		}
		vec3 gridCellSize = vec3(gridExtent * 0.04f);
		uvec3 gridCellIndex = uvec3((vec3(gridExtent * 0.5f) + gridVector) / gridCellSize);

		uint lightsCount = gridLightsData.gridList.grid[gridIndex].data[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z][0];
		for (uint lightIndex = 2; lightIndex < lightsCount + 2; lightIndex++)
		{
			uint lightIndicesPacked = gridLightsData.gridList.grid[gridIndex].data[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z][lightIndex / 2];
			LightInfo lightInfo = lightsList.lights[UnpackLightIndex(lightIndicesPacked, lightIndex)];
		}

		//------------------------------------------------------------------------------------------------------------------------------------------------

		uvec2 lightsPositions = gridLightsData.gridList.grid[gridIndex].lightOffsets[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z];
		uint directionalCount = (lightsPositions.x >> 8) & 0x000000ff;
		uint directionalOffset = lightsPositions.x & 0x000000ff;
		uint spotCount = (lightsPositions.x >> 24) & 0x000000ff;
		uint spotOffset = (lightsPositions.x >> 16) & 0x000000ff;
		uint pointCount = (lightsPositions.y >> 8) & 0x000000ff;
		uint pointOffset = lightsPositions.y & 0x000000ff;

		uint lightIndex = 0;
		for (uint index = directionalOffset; index < directionalOffset + directionalCount; index++)
		{
			uint lightIndicesPacked = gridLightsData.gridList.grid[gridIndex].data[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z][index / 2];
			LightInfo lightInfo = lightsList.lights[UnpackLightIndex(lightIndicesPacked, index)];

			vec3 pixelToLightDir = -lightInfo.direction.xyz;
			//float surfaceCosine = dot(normalize(pixelToLightDir), N);

//			if (surfaceCosine >= 0.0f)
			{
				traceRayEXT(tlas,						// acceleration structure
					  rayFlags,							// rayFlags
					  0xFF,								// cullMask
					  1,								// sbtRecordOffset
					  0,								// sbtRecordStride
					  0,								// missIndex
					  payloadGI.worldPos,				// ray origin
					  tMin,								// ray min range
					  normalize(pixelToLightDir.xyz),	// ray direction
					  tMax,								// ray max range
					  1									// payload (location = 0)
				);
				if (payloadGI.instanceCustomId == 0xffffffff)
				{
					accumulatedLight += lightInfo.color.xyz;
				}
			}
		}
		for (uint index = spotOffset; index < spotOffset + spotCount; index++)
		{
			uint lightIndicesPacked = gridLightsData.gridList.grid[gridIndex].data[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z][index / 2];
			LightInfo lightInfo = lightsList.lights[UnpackLightIndex(lightIndicesPacked, index)];

			vec3 pixelToLightDir = lightInfo.position.xyz - payloadGI.worldPos;
			float cosine = dot( normalize(-1.0 * pixelToLightDir), normalize(lightInfo.direction.xyz) );
			float spotCosine = cos(radians(lightInfo.rai.y));
			float angleFactor = clamp(cosine - spotCosine, 0.0f, 1.0f);// / clamp(1.0f - spotCosine, 0.0f, 1.0f);
			//float surfaceCosine = dot(normalize(pixelToLightDir), N);

			//if (surfaceCosine >= 0.0f)
			{
				traceRayEXT(tlas,							// acceleration structure
					  rayFlags,								// rayFlags
					  0xFF,									// cullMask
					  1,									// sbtRecordOffset
					  0,									// sbtRecordStride
					  0,									// missIndex
					  payloadGI.worldPos,					// ray origin
					  tMin,									// ray min range
					  normalize(pixelToLightDir.xyz),		// ray direction
					  length(pixelToLightDir),				// ray max range
					  1										// payload (location = 0)
				);
				if (payloadGI.instanceCustomId == 0xffffffff)
				{
					float lightRadiusSqr = lightInfo.rai.x * lightInfo.rai.x;
					float pixelDistanceSqr = dot(pixelToLightDir, pixelToLightDir);
					float distanceFactor = max(lightRadiusSqr - pixelDistanceSqr, 0) / max(lightRadiusSqr, 0.001);
					accumulatedLight += angleFactor * distanceFactor * lightInfo.color.xyz;
				}
			}
		}
		for (uint index = pointOffset; index < pointOffset + pointCount; index++)
		{
			uint lightIndicesPacked = gridLightsData.gridList.grid[gridIndex].data[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z][index / 2];
			LightInfo lightInfo = lightsList.lights[UnpackLightIndex(lightIndicesPacked, index)];

			vec3 pixelToLightDir = lightInfo.position.xyz - payloadGI.worldPos;
			//float surfaceCosine = dot(normalize(pixelToLightDir), N);

			//if (surfaceCosine >= 0.0f)
			{
				traceRayEXT(tlas,								// acceleration structure
					  rayFlags,									// rayFlags
					  0xFF,										// cullMask
					  1,										// sbtRecordOffset
					  0,										// sbtRecordStride
					  0,										// missIndex
					  payloadGI.worldPos,						// ray origin
					  tMin,										// ray min range
					  normalize(pixelToLightDir.xyz),			// ray direction
					  length(pixelToLightDir),					// ray max range
					  1											// payload (location = 0)
				);
				if (payloadGI.instanceCustomId == 0xffffffff)
				{
					float lightRadiusSqr = lightInfo.rai.x * lightInfo.rai.x;
					float pixelDistanceSqr = dot(pixelToLightDir, pixelToLightDir);
					float distanceFactor = max(lightRadiusSqr - pixelDistanceSqr, 0) / max(lightRadiusSqr, 0.001);
					accumulatedLight += distanceFactor * lightInfo.color.xyz;
				}
			}
		}
		
		accumulatedLight *= initialDistanceFactor * initialSurfaceCos;
	}

	totalLight = mix(totalLight, albedo * accumulatedLight, 1.0 / float(sampleStep));

	++temporalCounter;
	imageStore(counterTex, ivec2(gl_LaunchIDEXT.xy), uvec4(temporalCounter, 0,0,0));
	imageStore(lightTex, ivec2(gl_LaunchIDEXT.xy), vec4(totalLight, 1.0));
}