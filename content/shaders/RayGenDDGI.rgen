#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable


#include "CommonFrameData.glsl"
#include "CommonRay.glsl"
#include "CommonSampling.glsl"
#include "CommonLight.glsl"
#include "CommonDepth.glsl"

layout(location = 0) rayPayloadEXT HitPayloadDebug payloadDebug;
layout(location = 1) rayPayloadEXT HitPayloadGI payloadGI;

//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
// SET 1

layout(set = 1, binding = 0) uniform texture2D normalTex;
layout(set = 1, binding = 1) uniform texture2D depthTex;
// light clustering data
layout(set = 1, binding = 2) readonly buffer ClusterLightsData
{
	uvec2 clusters[32][32][64];
	uint lightIndices[32][32][64][128];
} clusterLightsData;
// lights list data
struct LightInfo
{
	vec4 position;
	vec4 direction;
	vec4 color;
	vec4 rai;
};
layout(set = 1, binding = 3) uniform LightsList
{
	LightInfo lights[1024];
} lightsList;
layout(set = 1, binding = 4) uniform LightsIndices
{
	uvec2 directionalPosition;
	uvec2 spotPosition;
	uvec2 pointPosition;
} lightsIndices;

layout(set = 1, binding = 5) uniform accelerationStructureEXT tlas;
layout(set = 1, binding = 6, rgba16f) uniform image2D lightTex;
layout(set = 1, binding = 7, rgba8) uniform image2D visibilityTextures[32];

//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
// SET 2

layout(set = 2, binding = 0) uniform SamplingPoints
{
//	CoordinateList samplingPoints;
	vec4 coords[2048];
	uint size;
} samplingPoints;

layout(buffer_reference, std430, buffer_reference_align = 4) buffer Grid
{
	uvec2 lightOffsets[25][25][25];
    uint data[25][25][25][128];
};

layout(buffer_reference, std430, buffer_reference_align = 8) buffer Grids
{
	Grid grid[];
};

layout(set = 2, binding = 1) readonly buffer GridLightsData
{
	uvec4 gridSpecs;
	uint lightsPerCell;
	Grids gridList;
} gridLightsData;

layout(set = 2, binding = 2) uniform texture2D directLightTex;
layout(set = 2, binding = 3) uniform texture2D previousLightTex;
layout(set = 2, binding = 4) uniform texture2D previousDepthTex;
layout(set = 2, binding = 5) uniform texture2D previousNormalTex;
layout(set = 2, binding = 6) uniform texture2D velocityTex;
layout(set = 2, binding = 7) uniform texture2D albedoTex;

layout(set = 2, binding = 8, r32ui) uniform uimage2D counterTex;
layout(set = 2, binding = 9, r32f) uniform image2D giDepthTex;

layout(set = 2, binding = 10) buffer ProbesBuffer
{
	DDGIProbe probes[32][16][32];
} probesBuffer;
layout(set = 2, binding = 11, rgba16f) uniform image2D probesImage;
layout(set = 2, binding = 12, rg16f) uniform image2D probesDepthImage;

//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------

bool CheckAndAccumulateViewSpaceVisibility(vec4 viewSpacePosition, inout vec3 color)
{
	if (viewSpacePosition.z < globalData.cameraNear || viewSpacePosition.z > globalData.cameraFar)
	{
		return false;
	}
	float maxY = viewSpacePosition.z * tan(radians(globalData.cameraFov * 0.5));
	float maxX = maxY * globalData.cameraAspect;

	if (abs(viewSpacePosition.x) > abs(maxX) || abs(viewSpacePosition.y) > abs(maxY))
	{
		return false;
	}

	vec2 halfScreenOffset = vec2(maxX, maxY);
	vec2 uv = (viewSpacePosition.xy + halfScreenOffset) / (halfScreenOffset * 2.0f);

	// compare depth in this point
	float depth = texture(sampler2D( depthTex, repeatLinearSampler ), uv).r;
	if (depth == 0.0 || depth >= 1.0)
	{
		return false;
	}

	float near = globalData.cameraNear;
	float far = globalData.cameraFar;
	float linearDepth = near * far / (far + depth * (near - far));

	if (abs(linearDepth - viewSpacePosition.z) >= 0.01f)
	{
		return false;
	}

	vec2 uvPrev = uv + texture(sampler2D( velocityTex, repeatLinearSampler ), uv).xy;
	float prevDepth = texture(sampler2D( previousDepthTex, repeatLinearSampler ), uv).r;
	float prevLinearDepth = LinearizeDepth(prevDepth, near, far);

	if (abs(linearDepth - prevLinearDepth) >= 0.01f)
	{
		return false;
	}

	color = texture(sampler2D(previousLightTex, repeatLinearSampler), uvPrev).xyz;
	//color = imageLoad(previousLightTex, ivec2(imageSize(previousLightTex) * uvPrev)).xyz;

	return true;
}

//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------

void main() 
{
	float tMin = 0.1f;
	float tMax = 100.0f;
    uint rayFlags = gl_RayFlagsOpaqueEXT;
	vec3 accumulatedLight = vec3(0.0f, 0.0f, 0.0f);
	ivec2 lightTexSize = imageSize(lightTex);

	//----------------------------------------------------------------------------------------------------------------------------------
	// extract UVs 
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5, 0.5);
    const vec2 uv = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	const vec2 velocity = texture( sampler2D( velocityTex, borderBlackLinearSampler ), uv ).xy / 10.0f;
	const vec2 prevUV = uv + velocity;

	//----------------------------------------------------------------------------------------------------------------------------------
	// albedo
	vec3 albedo = texture(sampler2D( albedoTex, repeatLinearSampler ), uv).xyz;

	//----------------------------------------------------------------------------------------------------------------------------------
	// extract depth and world positions
//	float near = globalData.cameraNear;
//	float far = globalData.cameraFar;
//	float depth = texture(sampler2D( depthTex, borderBlackNearestSampler ), uv).r;
//	imageStore(giDepthTex, ivec2(gl_LaunchIDEXT.xy), vec4(depth, 0.0f, 0.0f, 0.0));
//	if (depth <= 0.0f || depth >= 1.0f)
//	{
//		imageStore(lightTex, ivec2(gl_LaunchIDEXT.xy), vec4(0.0f, 0.0f, 0.0f, 1.0));
//		return;
//	}
//	float linearDepth = near * far / (far + depth * (near - far));
//	vec4 pixelCoordWorld = CalculateWorldPosition(linearDepth, globalData.cameraFov, globalData.cameraAspect, uv, globalData.worldToView);
//
//	float previousDepth = texture(sampler2D( previousDepthTex, borderBlackNearestSampler ), prevUV).r;
//	float previousLinearDepth = LinearizeDepth(previousDepth, globalPreviousData.cameraNear, globalPreviousData.cameraFar);
//	vec4 previousPixelCoordWorld = CalculateWorldPosition(previousLinearDepth, globalPreviousData.cameraFov, globalPreviousData.cameraAspect, prevUV, globalPreviousData.worldToView);

	//----------------------------------------------------------------------------------------------------------------------------------
	// probes data
	DDGIProbe probe = probesBuffer.probes[gl_LaunchIDEXT.x][gl_LaunchIDEXT.y][gl_LaunchIDEXT.z];
	uvec2 probeTexCoord = uvec2(probe.texturePosition >> 16, probe.texturePosition & 0xffffu);
	uvec2 probeDepthCoord = uvec2(probe.depthPosition >> 16, probe.depthPosition & 0xffffu);
	uint temporalCounter = probe.temporalCounter;
	probesBuffer.probes[gl_LaunchIDEXT.x][gl_LaunchIDEXT.y][gl_LaunchIDEXT.z].temporalCounter += 1;

	// ray start
	vec3 rayStart = probe.position.xyz;

	uint samplePoolSize = 10101;
	uint sampleStep = samplePoolSize / 32;
	uint sampleStart = uint(mod(temporalCounter, sampleStep));
	uint randSeed = InitRNG(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, globalData.frameIndex);

	for (uint idx = sampleStart; idx < samplePoolSize; idx += sampleStep)
	{
		vec3 jitter = vec3(Rand(randSeed), Rand(randSeed), Rand(randSeed));
		jitter = 0.05f * normalize(jitter - vec3(0.5f));

		vec3 direction = normalize(SphericalFibonacci(idx, samplePoolSize) + jitter);
		vec2 directionUV = DirectionToOctahedronUV(direction);

		vec2 targetPixelUV = directionUV * 6.0;
		vec2 targetPixelUVMin = mod(floor(targetPixelUV - 0.5 + 6.0) + 0.5, 6.0);

		vec2 targetDepthPixelUV = directionUV * 16.0;
		vec2 targetDepthPixelUVMin = mod(floor(targetPixelUV - 0.5 + 16.0) + 0.5, 16.0);

		traceRayEXT(tlas,							// acceleration structure
				rayFlags,							// rayFlags
				0xFF,								// cullMask
				1,									// sbtRecordOffset
				0,									// sbtRecordStride
				0,									// missIndex
				rayStart,							// ray origin
				tMin,								// ray min range
				direction,							// ray direction
				tMax,								// ray max range
				1									// payload (location = 0)
		);

		if (payloadGI.instanceCustomId == 0xffffffff)
		{
//			vec2 totalDepth = imageLoad(probesDepthImage, ivec2(targetDepthPixel)).xy;
//			totalDepth = mix(totalDepth, vec2(tMax, tMax * tMax), 1.0f / float(sampleStep));
//			imageStore(probesDepthImage, ivec2(targetDepthPixel), vec4(totalDepth, 0.0, 0.0));
			continue;
		}

		uint initialInstanceId = payloadGI.instanceCustomId;
		float hitDepth = payloadGI.hitT;

		//------------------------------------------------------------------------------------------------------------------------------------------------
		//------------------------------------------------------------------------------------------------------------------------------------------------
		// falloff
		vec3 pointDistance = rayStart - payloadGI.worldPos;
		float lightMaxRadiusSqr = 1000000.0;
		float pointDistanceSqr = dot(pointDistance, pointDistance);
		float initialDistanceFactor = max(lightMaxRadiusSqr - pointDistanceSqr, 0) / max(lightMaxRadiusSqr, 0.001);
		//------------------------------------------------------------------------------------------------------------------------------------------------
		//------------------------------------------------------------------------------------------------------------------------------------------------

		vec3 gridVector = payloadGI.worldPos - globalData.cameraPos;
		float maxExtent = 2.0f * max(abs(gridVector.x), max(abs(gridVector.y), abs(gridVector.z)));
		float gridExtent = gridLightsData.gridSpecs.x; // account for cell size
		uint gridIndex = 0;
		for (; gridIndex < gridLightsData.gridSpecs.w; gridIndex++)
		{
			if (maxExtent <= gridExtent)
			{
				break;
			}
			gridExtent *= 5.0f;
		}
		vec3 gridCellSize = vec3(gridExtent * 0.04f);
		uvec3 gridCellIndex = uvec3((vec3(gridExtent * 0.5f) + gridVector) / gridCellSize);

		uint lightsCount = gridLightsData.gridList.grid[gridIndex].data[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z][0];
		for (uint lightIndex = 2; lightIndex < lightsCount + 2; lightIndex++)
		{
			uint lightIndicesPacked = gridLightsData.gridList.grid[gridIndex].data[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z][lightIndex / 2];
			LightInfo lightInfo = lightsList.lights[UnpackLightIndex(lightIndicesPacked, lightIndex)];
		}

		//------------------------------------------------------------------------------------------------------------------------------------------------

		uvec2 lightsPositions = gridLightsData.gridList.grid[gridIndex].lightOffsets[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z];
		uint directionalCount = (lightsPositions.x >> 8) & 0x000000ff;
		uint directionalOffset = lightsPositions.x & 0x000000ff;
		uint spotCount = (lightsPositions.x >> 24) & 0x000000ff;
		uint spotOffset = (lightsPositions.x >> 16) & 0x000000ff;
		uint pointCount = (lightsPositions.y >> 8) & 0x000000ff;
		uint pointOffset = lightsPositions.y & 0x000000ff;

		uint lightIndex = 0;
		for (uint index = directionalOffset; index < directionalOffset + directionalCount; index++)
		{
			uint lightIndicesPacked = gridLightsData.gridList.grid[gridIndex].data[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z][index / 2];
			LightInfo lightInfo = lightsList.lights[UnpackLightIndex(lightIndicesPacked, index)];

			vec3 pixelToLightDir = -lightInfo.direction.xyz;
			//float surfaceCosine = dot(normalize(pixelToLightDir), N);

//			if (surfaceCosine >= 0.0f)
			{
				traceRayEXT(tlas,						// acceleration structure
					  rayFlags,							// rayFlags
					  0xFF,								// cullMask
					  1,								// sbtRecordOffset
					  0,								// sbtRecordStride
					  0,								// missIndex
					  payloadGI.worldPos,				// ray origin
					  tMin,								// ray min range
					  normalize(pixelToLightDir.xyz),	// ray direction
					  tMax,								// ray max range
					  1									// payload (location = 0)
				);
				if (payloadGI.instanceCustomId == 0xffffffff)
				{
					accumulatedLight += lightInfo.color.xyz;
				}
			}
		}
		for (uint index = spotOffset; index < spotOffset + spotCount; index++)
		{
			uint lightIndicesPacked = gridLightsData.gridList.grid[gridIndex].data[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z][index / 2];
			LightInfo lightInfo = lightsList.lights[UnpackLightIndex(lightIndicesPacked, index)];

			vec3 pixelToLightDir = lightInfo.position.xyz - payloadGI.worldPos;
			float cosine = dot( normalize(-1.0 * pixelToLightDir), normalize(lightInfo.direction.xyz) );
			float spotCosine = cos(radians(lightInfo.rai.y));
			float angleFactor = clamp(cosine - spotCosine, 0.0f, 1.0f);// / clamp(1.0f - spotCosine, 0.0f, 1.0f);
			//float surfaceCosine = dot(normalize(pixelToLightDir), N);

			//if (surfaceCosine >= 0.0f)
			{
				traceRayEXT(tlas,							// acceleration structure
					  rayFlags,								// rayFlags
					  0xFF,									// cullMask
					  1,									// sbtRecordOffset
					  0,									// sbtRecordStride
					  0,									// missIndex
					  payloadGI.worldPos,					// ray origin
					  tMin,									// ray min range
					  normalize(pixelToLightDir.xyz),		// ray direction
					  length(pixelToLightDir),				// ray max range
					  1										// payload (location = 0)
				);
				if (payloadGI.instanceCustomId == 0xffffffff)
				{
					float lightRadiusSqr = lightInfo.rai.x * lightInfo.rai.x;
					float pixelDistanceSqr = dot(pixelToLightDir, pixelToLightDir);
					float distanceFactor = max(lightRadiusSqr - pixelDistanceSqr, 0) / max(lightRadiusSqr, 0.001);
					accumulatedLight += angleFactor * distanceFactor * lightInfo.color.xyz;
				}
			}
		}
		for (uint index = pointOffset; index < pointOffset + pointCount; index++)
		{
			uint lightIndicesPacked = gridLightsData.gridList.grid[gridIndex].data[gridCellIndex.x][gridCellIndex.y][gridCellIndex.z][index / 2];
			LightInfo lightInfo = lightsList.lights[UnpackLightIndex(lightIndicesPacked, index)];

			vec3 pixelToLightDir = lightInfo.position.xyz - payloadGI.worldPos;
			//float surfaceCosine = dot(normalize(pixelToLightDir), N);

			//if (surfaceCosine >= 0.0f)
			{
				traceRayEXT(tlas,								// acceleration structure
					  rayFlags,									// rayFlags
					  0xFF,										// cullMask
					  1,										// sbtRecordOffset
					  0,										// sbtRecordStride
					  0,										// missIndex
					  payloadGI.worldPos,						// ray origin
					  tMin,										// ray min range
					  normalize(pixelToLightDir.xyz),			// ray direction
					  length(pixelToLightDir),					// ray max range
					  1											// payload (location = 0)
				);
				if (payloadGI.instanceCustomId == 0xffffffff)
				{
					float lightRadiusSqr = lightInfo.rai.x * lightInfo.rai.x;
					float pixelDistanceSqr = dot(pixelToLightDir, pixelToLightDir);
					float distanceFactor = max(lightRadiusSqr - pixelDistanceSqr, 0) / max(lightRadiusSqr, 0.001);
					accumulatedLight += distanceFactor * lightInfo.color.xyz;
				}
			}
		}
		
		accumulatedLight *= initialDistanceFactor;

		// doing bilinear by hand to get a good distribution will limited pixel number
		vec2 alpha = clamp(min(targetPixelUV - targetPixelUVMin, targetPixelUV + vec2(6.0) - targetPixelUVMin), 0.0, 1.0);
		vec2 alphaDepth = clamp(min(targetDepthPixelUV - targetDepthPixelUVMin, targetDepthPixelUV + vec2(16.0) - targetDepthPixelUVMin), 0.0, 1.0);

		for (uint idx = 0; idx < 4; idx++)
		{
			ivec2 pixelStep = ivec2(idx, idx / 2) & ivec2(1, 1);
			// bilinear alphas
			vec2 bilinear = mix(vec2(1.0) - alpha, alpha, vec2(pixelStep));
			vec2 bilinearDepth = mix(vec2(1.0) - alphaDepth, alphaDepth, vec2(pixelStep));
			// bilinear weight
			float weight = bilinear.x * bilinear.y;
			float weightDepth = bilinearDepth.x * bilinearDepth.y;

			// pixel to write
			ivec2 currentPixel = ivec2(mod(ivec2(targetPixelUVMin) + pixelStep, ivec2(6,6)));
			currentPixel += ivec2(probeTexCoord) + ivec2(1,1); 
			// load pixel, mix and store
			vec3 totalLight = imageLoad(probesImage, currentPixel).xyz;
			totalLight = mix(totalLight, accumulatedLight * weight, 1.0f / float(sampleStep));
			imageStore(probesImage, currentPixel, vec4(totalLight, hitDepth * weight));

			// depth pixel coords
			ivec2 currentDepthPixel = ivec2(mod(ivec2(targetDepthPixelUVMin) + pixelStep, ivec2(16,16)));
			currentDepthPixel += ivec2(probeDepthCoord) + ivec2(1,1);
			// load depth, mix and store
			vec2 totalDepth = imageLoad(probesDepthImage, currentDepthPixel).xy;
			totalDepth = mix(totalDepth, vec2(hitDepth * weightDepth, hitDepth * hitDepth * weightDepth), 1.0f / float(sampleStep));
			imageStore(probesDepthImage, currentDepthPixel, vec4(totalDepth, 0.0, 0.0));
		}
	}

//	
	{
//		float lightValue = length(accumulatedLight);
//		totalLight = normalize(totalLight) * lightValue;
//		float totalValue = length(totalLight);

//		float minLight = min(accumulatedLight.x, min(accumulatedLight.y, accumulatedLight.z));
//		float maxLight = max(accumulatedLight.x, max(accumulatedLight.y, accumulatedLight.z));
		//totalLight = accumulatedLight;//clamp(totalLight, vec3(minLight), vec3(maxLight));
	}
//	if (temporalCounter < 1)
	{
//		totalLight += accumulatedLight * 0.5f;
	}
//	else
	{
//		totalLight = mix(totalLight, /*albedo */ accumulatedLight, 1.0f / float(sampleStep));
	}

//	++temporalCounter;
//	imageStore(counterTex, ivec2(gl_LaunchIDEXT.xy), uvec4(temporalCounter, 0,0,0));
//	imageStore(lightTex, ivec2(gl_LaunchIDEXT.xy), vec4(totalLight, 1.0));
}