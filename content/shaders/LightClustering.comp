#version 450
#extension GL_EXT_buffer_reference : require
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "CommonFrameData.glsl"

layout(set = 1, binding = 0) uniform texture2D depthTexture;
layout(set = 1, binding = 1, rgba8) uniform image2D storageTex;

// cluster lights indices
layout(set = 1, binding = 2) buffer ClusterLightsData
{
	uvec2 clusters[32][32][64];
	uint lightIndices[32][32][64][128];
} clusterLightsData;

// cluster lights

struct LightInfo
{
	vec4 position;
	vec4 direction;
	vec4 color;
	vec4 rai;
};

layout(set = 1, binding = 3) uniform LightsList
{
	LightInfo lights[1024];
} lightsList;

layout(set = 1, binding = 4) uniform LightsIndices
{
	uvec2 directionalPosition;
	uvec2 spotPosition;
	uvec2 pointPosition;
} lightsIndices;

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

uint Pack16BitIndex(uint lightIndexData, uint lightIndexInCluster, uint lightIndexGlobal)
{
	uint bitOffset = 16 * (lightIndexInCluster % 2);
	uint nullBits = 0xffff0000;
	// nullify
	lightIndexData &= nullBits >> bitOffset;
	// set
	lightIndexData |= lightIndexGlobal << bitOffset;

	return lightIndexData;
}

bool IsConeIntersectsSphere(vec3 coneOrigin, vec3 coneDir, float coneLength, float halfAngle, vec4 sphere)
{
    const vec3 centerToCenter = sphere.xyz - coneOrigin;
    const float centersDistanceSqr = dot(centerToCenter, centerToCenter);
	// vector between cone and sphere centers projected onto cone direction, do not forget to normalize coneDir
    const float projectionOnCone = dot(centerToCenter, coneDir);
	// this is simply can be calculated looking at similar triangles, v2 * tan(angle) - v1 * sin(angle) gives us distance to cone border,
	// where v2 is a distance from sphere center to the end of projection vector, which is vector between cone and sphere centers projected on cone direction
    const float distanceToConeBorder = cos(halfAngle) * sqrt(centersDistanceSqr - projectionOnCone*projectionOnCone) - projectionOnCone * sin(halfAngle);
 
    const bool isSphereOutsideConeAngle = distanceToConeBorder > sphere.w;
    const bool isOutsideFront = projectionOnCone > (sphere.w + coneLength);
    const bool isBehindBack  = projectionOnCone < -sphere.w;

	return !(isSphereOutsideConeAngle || isOutsideFront || isBehindBack);
}

void main()
{
	float near = globalData.cameraNear;
	float far = globalData.cameraFar;

	uint clusterIndex = gl_LocalInvocationIndex;
	uint nextClusterIndex = clusterIndex + 1;

	// find the light source intersections for this cluster
	// first we find our cluster bounds for AABB. clusters are small so it's an 'okay' approximation
	float clusterNear = -1.0 * near * pow(far/near, float(clusterIndex)/64.0);
	float clusterFar = -1.0 * near * pow(far/near, float(nextClusterIndex)/64.0);

	float fovMultiplier = tan(radians(globalData.cameraFov * 0.5)) * 2.0;
	float nearHeight = globalData.clusterScreenOverflow.y * abs(clusterNear * fovMultiplier);
	float farHeight = globalData.clusterScreenOverflow.y * abs(clusterFar * fovMultiplier);
	float nearWidth = globalData.clusterScreenOverflow.x * nearHeight * globalData.cameraAspect;
	float farWidth = globalData.clusterScreenOverflow.x * farHeight * globalData.cameraAspect;

	float clusterLeft = min(nearWidth * (-0.5f + float(gl_WorkGroupID.x) / float(globalData.numClusters.x)), farWidth * (-0.5f + float(gl_WorkGroupID.x) / float(globalData.numClusters.x)));
	float clusterRight = max(nearWidth * (-0.5f + float(gl_WorkGroupID.x + 1) / float(globalData.numClusters.x)), farWidth * (-0.5f + float(gl_WorkGroupID.x + 1) / float(globalData.numClusters.x)));

	float clusterBottom = min(nearHeight * (-0.5f + float(gl_WorkGroupID.y) / float(globalData.numClusters.y)), farHeight * (-0.5f + float(gl_WorkGroupID.y) / float(globalData.numClusters.y)));
	float clusterTop = max(nearHeight * (-0.5f + float(gl_WorkGroupID.y + 1) / float(globalData.numClusters.y)), farHeight * (-0.5f + float(gl_WorkGroupID.y + 1) / float(globalData.numClusters.y)));

	// we make an AABB from our cluster frustum and then we make a sphere out of it
	vec4 boundingSphere;
	vec3 clusterExtentMax = vec3(clusterRight, clusterTop, clusterNear);
	vec3 clusterExtentMin = vec3(clusterLeft, clusterBottom, clusterFar);
	vec3 extents = (clusterExtentMax - clusterExtentMin) * 0.5;
	boundingSphere.xyz = clusterExtentMin + extents;
	boundingSphere.w = length(extents);

	uint lightIndexInCluster = 0;

	for (uint index = lightsIndices.directionalPosition.x; index < lightsIndices.directionalPosition.x + lightsIndices.directionalPosition.y; index++)
	{
		LightInfo lightInfo = lightsList.lights[index];

		uint entryIndex = lightIndexInCluster / 2;
		uint lightIndexData = clusterLightsData.lightIndices[gl_WorkGroupID.x][gl_WorkGroupID.y][clusterIndex][entryIndex];
		lightIndexData = Pack16BitIndex(lightIndexData, lightIndexInCluster, index);
		clusterLightsData.lightIndices[gl_WorkGroupID.x][gl_WorkGroupID.y][clusterIndex][entryIndex] = lightIndexData;			

		lightIndexInCluster++;
	}
	uint directionalLightOffsetData = clusterLightsData.clusters[gl_WorkGroupID.x][gl_WorkGroupID.y][clusterIndex].x;
	directionalLightOffsetData &= 0xffff0000;
	// offset is always 0
	directionalLightOffsetData |= 0x0000ff00 & (lightIndexInCluster << 8);
	clusterLightsData.clusters[gl_WorkGroupID.x][gl_WorkGroupID.y][clusterIndex].x = directionalLightOffsetData;

	uint spotLightOffset = lightIndexInCluster;
	uint spotLightCount = 0;
	for (uint index = lightsIndices.spotPosition.x; index < lightsIndices.spotPosition.x + lightsIndices.spotPosition.y; index++)
	{
		if (lightIndexInCluster > 255)
		{
			break;
		}

		LightInfo lightInfo = lightsList.lights[index];
		vec4 lightPos = globalData.worldToView * vec4(lightInfo.position.xyz, 1.0);
		lightPos /= lightPos.w;
		vec4 lightDir4 = globalData.worldToView * vec4(lightInfo.direction.xyz, 0.0);
		lightDir4 /= lightDir4.w;
		vec3 lightDir = lightDir4.xyz;

		if (!IsConeIntersectsSphere(lightPos.xyz, lightDir, lightInfo.rai.x, radians(lightInfo.rai.y), boundingSphere))
		{
			continue;
		}
		spotLightCount++;

		uint entryIndex = lightIndexInCluster / 2;
		uint lightIndexData = clusterLightsData.lightIndices[gl_WorkGroupID.x][gl_WorkGroupID.y][clusterIndex][entryIndex];
		lightIndexData = Pack16BitIndex(lightIndexData, lightIndexInCluster, index);
		clusterLightsData.lightIndices[gl_WorkGroupID.x][gl_WorkGroupID.y][clusterIndex][entryIndex] = lightIndexData;			

		lightIndexInCluster++;
	}
	uint spotLightOffsetData = clusterLightsData.clusters[gl_WorkGroupID.x][gl_WorkGroupID.y][clusterIndex].x;
	spotLightOffsetData &= 0x0000ffff;
	spotLightOffsetData |= 0x00ff0000 & (spotLightOffset << 16);
	spotLightOffsetData |= 0xff000000 & (spotLightCount << 24);
	clusterLightsData.clusters[gl_WorkGroupID.x][gl_WorkGroupID.y][clusterIndex].x = spotLightOffsetData;

	uint pointLightOffset = lightIndexInCluster;
	uint pointLightCount = 0;
	for (uint index = lightsIndices.pointPosition.x; index < lightsIndices.pointPosition.x + lightsIndices.pointPosition.y; index++)
	{
		if (lightIndexInCluster > 255)
		{
			break;
		}
		LightInfo lightInfo = lightsList.lights[index];
		vec4 lightPos = globalData.worldToView * vec4(lightInfo.position.xyz, 1.0);
		lightPos /= lightPos.w;

		vec3 lightSphereClippedPos = clamp(lightPos.xyz, clusterExtentMin, clusterExtentMax);
		vec3 centerToAABB = lightSphereClippedPos - lightPos.xyz;

		if (dot(centerToAABB, centerToAABB) > (lightInfo.rai.x * lightInfo.rai.x))
		{
			continue;
		}
		pointLightCount++;

		uint entryIndex = lightIndexInCluster / 2;
		uint lightIndexData = clusterLightsData.lightIndices[gl_WorkGroupID.x][gl_WorkGroupID.y][clusterIndex][entryIndex];
		lightIndexData = Pack16BitIndex(lightIndexData, lightIndexInCluster, index);
		clusterLightsData.lightIndices[gl_WorkGroupID.x][gl_WorkGroupID.y][clusterIndex][entryIndex] = lightIndexData;

		lightIndexInCluster++;
	}
	uint pointLightOffsetData = clusterLightsData.clusters[gl_WorkGroupID.x][gl_WorkGroupID.y][clusterIndex].y;
	pointLightOffsetData &= 0xffff0000;
	pointLightOffsetData |= 0x000000ff & pointLightOffset;
	pointLightOffsetData |= 0x0000ff00 & (pointLightCount << 8);
	clusterLightsData.clusters[gl_WorkGroupID.x][gl_WorkGroupID.y][clusterIndex].y = pointLightOffsetData;

	//vec4 color = vec4(depth, depth, depth, 1.0);
	//imageStore(storageTex, ivec2(pixelUV * vec2(63,63)), color);//vec4(vec3(gl_LocalInvocationID) / vec3(gl_WorkGroupSize), 1.0));
}
