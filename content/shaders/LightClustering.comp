#version 450
#extension GL_ARB_separate_shader_objects : enable

#define PI 3.1415926535897932384626433832795

layout(set = 0, binding = 0) uniform sampler repeatLinearSampler;
layout(set = 0, binding = 1) uniform sampler repeatMirrorLinearSampler;
layout(set = 0, binding = 2) uniform sampler borderBlackLinearSampler;
layout(set = 0, binding = 3) uniform sampler borderWhiteLinearSampler;
layout(set = 0, binding = 4) uniform ShaderGlobalData
{
	mat4 worldToView;
	mat4 viewToProj;
	float time;
	float deltaTime;
	float cameraNear;
	float cameraFar;
	float cameraFov;
} globalData;

layout(set = 1, binding = 0) uniform texture2D depthTexture;
layout(set = 1, binding = 1, rgba8) uniform image2D storageTex;

// cluster lights indices
layout(set = 1, binding = 2) buffer ClusterLightsData
{
	uvec2 clusters[32][32][32];
	uint lightIndices[32][32][32][128];
} clusterLightsData;

// cluster lights
struct LightInfo
{
	vec3 position;
	vec3 direction;
	vec3 color;
	float intensity;
};
struct LightsList
{
	uvec2 directionalPosition;
	uvec2 spotPosition;
	uvec2 pointPosition;
	LightInfo lights[4096];
} lightsList;

// shared
shared uint clusterStatus[32];

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

void main() {
	float near = globalData.cameraNear;
	float far = globalData.cameraFar;

	uvec2 screenRes = textureSize(sampler2D( depthTexture, repeatLinearSampler ), 0);
	vec2 pixelUVHalfSize =  0.5 / vec2(screenRes);
	vec2 tileSize = vec2(screenRes) / vec2(gl_NumWorkGroups.xy);

	uvec2 tileStart = uvec2( vec2(0.5, 0.5) + tileSize * vec2(gl_WorkGroupID.xy) );
	uvec2 tileFinish = uvec2( vec2(0.5, 0.5) + tileSize * (vec2(gl_WorkGroupID.xy) + vec2(1.0, 1.0)) );

	//uint gl_LocalInvocationIndex
	uvec2 tilePixelSize = tileFinish - tileStart;
	uint tilePixelsCount = tilePixelSize.x * tilePixelSize.y;
	if (gl_LocalInvocationIndex >= tilePixelsCount)
	{
		return;
	}

	uint workgroupSize = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;
	uint pixelCount = (tilePixelsCount / workgroupSize) + clamp((tilePixelsCount % workgroupSize) / gl_LocalInvocationIndex, 0, 1);

	for (uint index = 0; index < pixelCount; index++)
	{
		uint pixelIndex = gl_LocalInvocationIndex + (index * workgroupSize);
		uvec2 tileCoord = uvec2(pixelIndex % tilePixelSize.x, pixelIndex / tilePixelSize.x);
		vec2 pixelUV = pixelUVHalfSize + vec2(tileStart + tileCoord) / vec2(screenRes);

		float depth = texture(sampler2D( depthTexture, repeatLinearSampler ), pixelUV).r;
		if (depth <= 0.0 || depth >= 1.0)
		{
			//imageStore(storageTex, ivec2(pixelUV * vec2(63,63)), vec4(0.0, 0.0, 0.0, 1.0));
			continue;
		}

		float linearDepth = near * far / (far + depth * (near - far));
		// depthSlice = near * (far/near) ^ (slice/numSlices) --- pretty good distribution from Doom 2016
		// cluster index = maxClusters * log(linearDepth/near) / log(far/near);
		uint clusterIndex = clamp(uint(32.0 * log(linearDepth/near) / log(far/near)), 0, 31); // clump it for zero based index just in case
		uint nextClusterIndex = clusterIndex + 1;
		uint clusterChecked = atomicOr(clusterStatus[clusterIndex], 1);
		if (clusterChecked != 0)
		{
			continue;
		}

		// TODO: find the light source intersections for this cluster
		float clusterNear = near * pow(far/near, float(clusterIndex)/32.0);
		float clusterFar = near * pow(far/near, float(nextClusterIndex)/32.0);

		float fovMultiplier = tan(radians(globalData.cameraFov * 0.5)) * 2.0;
		float nearWidth = clusterNear * fovMultiplier;
		float farWidth = clusterFar * fovMultiplier;
		float reverseAspectRatio = float(screenRes.y) / float(screenRes.x);
		float nearHeight = nearWidth * reverseAspectRatio;
		float farHeight = farWidth * reverseAspectRatio;

		float clusterLeft = min(-nearWidth * 0.5 + gl_WorkGroupID.x * nearWidth / 32.0, -farWidth * 0.5 + gl_WorkGroupID.x * farWidth / 32.0);
		float clusterRight = max(-nearWidth * 0.5 + (gl_WorkGroupID.x + 1) * nearWidth / 32.0, -farWidth * 0.5 + (gl_WorkGroupID.x + 1) * farWidth / 32.0);

		float clusterBottom = min(-nearHeight * 0.5 + gl_WorkGroupID.y * nearHeight / 32.0, -farHeight * 0.5 + gl_WorkGroupID.y * farHeight / 32.0);
		float clusterTop = max(-nearHeight * 0.5 + (gl_WorkGroupID.y + 1) * nearHeight / 32.0, -farHeight * 0.5 + (gl_WorkGroupID.y + 1) * farHeight / 32.0);

		clusterLightsData.lightIndices[gl_WorkGroupID.x][gl_WorkGroupID.y][clusterIndex][13] = 2265330;
		vec4 color = vec4(depth, depth, depth, 1.0);
		imageStore(storageTex, ivec2(pixelUV * vec2(63,63)), color);//vec4(vec3(gl_LocalInvocationID) / vec3(gl_WorkGroupSize), 1.0));
	}	
}
