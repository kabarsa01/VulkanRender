#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference : require
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "CommonFrameData.glsl"
#include "CommonRay.glsl"
#include "CommonSampling.glsl"

layout(set = 1, binding = 0) buffer ProbesBuffer
{
	DDGIProbe probes[32][16][32];
} probeGridData;
layout(set = 1, binding = 1, rgba16f) uniform image2D probeTexture;
layout(set = 1, binding = 2) uniform texture2D probeDepthTexture;

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

void main()
{
	// gl_WorkGroupID
	// gl_LocalInvocationIndex
	uint randSeed = InitRNG(gl_WorkGroupID.xy, gl_NumWorkGroups.xy, globalData.frameIndex);
	int start = int(27 * Rand(randSeed));

	for (int idx = start; idx < start + 27; idx++)
	{
		int index = idx % 27;
		ivec3 offsetIndex = ivec3(-1, -1, -1) + ivec3(index / 9, index / 3 % 3, index % 3);
		if (offsetIndex == ivec3(0,0,0))
		{
			continue;
		}

		offsetIndex += ivec3(gl_WorkGroupID.x, gl_WorkGroupID.y, gl_LocalInvocationIndex);
		if (min(offsetIndex.x, min(offsetIndex.y, offsetIndex.z)) < 0)
		{
			continue;
		}
		if ((offsetIndex.y > 15) || (max(offsetIndex.x, offsetIndex.z) > 31))
		{
			continue;
		}

		DDGIProbe currentProbe = probeGridData.probes[gl_WorkGroupID.x][gl_WorkGroupID.y][gl_LocalInvocationIndex];
		DDGIProbe otherProbe = probeGridData.probes[offsetIndex.x][offsetIndex.y][offsetIndex.z];

		vec2 probeTextureSize = vec2(imageSize( probeTexture ));
		vec2 probeDepthTextureSize = vec2(textureSize( sampler2D( probeDepthTexture, borderBlackLinearSampler ), 0 ));

		vec3 probePosDiff = otherProbe.position.xyz - currentProbe.position.xyz;
		vec3 dir = normalize(probePosDiff);
		float dist = length(probePosDiff);

		vec2 oemUV = DirectionToOctahedronUV(dir);
		vec2 oemDepthUV = DirectionToOctahedronUV(-1.0 * dir);

		vec3 color = vec3(0.0);
		vec2 depth = vec2(0.0);

		{
			ivec2 otherProbeTexCoord = ivec2(otherProbe.texturePosition >> 16, otherProbe.texturePosition & 0xffffu);
			ivec2 otherProbeDepthCoord = ivec2(otherProbe.depthPosition >> 16, otherProbe.depthPosition & 0xffffu);

			ivec2 otherPixelCoord = otherProbeTexCoord + ivec2(1, 1) + ivec2(6.0 * oemUV);
			vec2 otherDepthUV = (otherProbeDepthCoord + vec2(1.0, 1.0) + 16.0 * oemDepthUV) / probeDepthTextureSize;

			for (int x = -1; x < 2; x++)
			{
				for (int y = -1; y < 2; y++)
				{
					color += imageLoad(probeTexture, otherPixelCoord + ivec2(x,y)).xyz;
				}
			}
			color /= 9.0;
			depth = texture(sampler2D( probeDepthTexture, borderBlackLinearSampler ), otherDepthUV).xy;
		}

		//if (depth.x >= length(otherProbe.position.xyz - currentProbe.position.xyz))
		{
			ivec2 currentProbeTexCoord = ivec2(currentProbe.texturePosition >> 16, currentProbe.texturePosition & 0xffffu);
			ivec2 currentPixelCoord = currentProbeTexCoord + ivec2(1, 1) + ivec2(6.0 * oemUV);

			vec3 luminance = imageLoad(probeTexture, currentPixelCoord).xyz;
			color *= dist / 1.5;
			//luminance += color;
			color = max(luminance, color);
			imageStore(probeTexture, currentPixelCoord, vec4(mix(luminance, color, 1.0), 1.0));
			//imageStore(probeTexture, currentPixelCoord, vec4(dir, 1.0));
		}

	}
}
